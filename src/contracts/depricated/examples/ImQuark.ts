/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../../common";

export declare namespace ImQuark {
  export type CreateCollectionParamsStruct = {
    templateIds: PromiseOrValue<BigNumberish>[];
    collectionIds: PromiseOrValue<BigNumberish>[];
    totalSupplies: PromiseOrValue<BigNumberish>[];
  };

  export type CreateCollectionParamsStructOutput = [
    BigNumber[],
    BigNumber[],
    number[]
  ] & {
    templateIds: BigNumber[];
    collectionIds: BigNumber[];
    totalSupplies: number[];
  };

  export type SellOrderStruct = {
    seller: PromiseOrValue<string>;
    fromContractAddress: PromiseOrValue<string>;
    fromTokenId: PromiseOrValue<BigNumberish>;
    projectId: PromiseOrValue<BigNumberish>;
    slotUri: PromiseOrValue<string>;
    sellPrice: PromiseOrValue<BigNumberish>;
  };

  export type SellOrderStructOutput = [
    string,
    string,
    BigNumber,
    BigNumber,
    string,
    BigNumber
  ] & {
    seller: string;
    fromContractAddress: string;
    fromTokenId: BigNumber;
    projectId: BigNumber;
    slotUri: string;
    sellPrice: BigNumber;
  };

  export type BuyOrderStruct = {
    buyer: PromiseOrValue<string>;
    seller: PromiseOrValue<string>;
    fromContractAddress: PromiseOrValue<string>;
    fromTokenId: PromiseOrValue<BigNumberish>;
    toContractAddress: PromiseOrValue<string>;
    toTokenId: PromiseOrValue<BigNumberish>;
    projectId: PromiseOrValue<BigNumberish>;
    slotUri: PromiseOrValue<string>;
    buyPrice: PromiseOrValue<BigNumberish>;
  };

  export type BuyOrderStructOutput = [
    string,
    string,
    string,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    string,
    BigNumber
  ] & {
    buyer: string;
    seller: string;
    fromContractAddress: string;
    fromTokenId: BigNumber;
    toContractAddress: string;
    toTokenId: BigNumber;
    projectId: BigNumber;
    slotUri: string;
    buyPrice: BigNumber;
  };
}

export interface ImQuarkInterface extends utils.Interface {
  functions: {
    "addBatchURISlotToNFTs(address,address[],uint256[],uint256,string)": FunctionFragment;
    "addBatchURISlotsToNFT(address,address,uint256,uint256[],string[])": FunctionFragment;
    "addURISlotToNFT(address,address,uint256,uint256,string)": FunctionFragment;
    "createCollections(address,uint256,address,(uint256[],uint256[],uint16[]),bytes[][],string[][],bool[])": FunctionFragment;
    "createCollectionsWithoutURIs(address,uint256,(uint256[],uint256[],uint16[]),bool[])": FunctionFragment;
    "externalCollectionURI(address)": FunctionFragment;
    "getIsFreeMinted(uint256)": FunctionFragment;
    "getProjectCollection(uint256,uint256,uint256)": FunctionFragment;
    "getProjectLastCollectionId(uint256,uint256)": FunctionFragment;
    "isSlotAddedForProject(address,uint256,uint256)": FunctionFragment;
    "mint(address,uint256,uint256,uint256,uint256)": FunctionFragment;
    "mintBatch(address,uint256,uint256[],uint256[],uint256[],uint16[])": FunctionFragment;
    "mintBatchWithURISlot(address,uint256,uint256[],uint256[],uint256[],uint16[],string)": FunctionFragment;
    "mintFree(uint256,uint256,uint256,uint256)": FunctionFragment;
    "mintFreeWithPreURI(address,uint256,uint256,uint256,bytes,string,bytes)": FunctionFragment;
    "mintWithPreURI(address,address,uint256,uint256,uint256,bytes,string,bytes)": FunctionFragment;
    "mintWithURISlots(address,uint256,uint256,uint256,uint256[],string[])": FunctionFragment;
    "registerExternalCollection(address,string)": FunctionFragment;
    "safeTransferFrom(address,address,uint256)": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "tokenProjectURI(address,uint256,uint256)": FunctionFragment;
    "transferTokenProjectURI((address,address,uint256,uint256,string,uint256),(address,address,address,uint256,address,uint256,uint256,string,uint256),string)": FunctionFragment;
    "unlockFreeMintNFT(uint256,uint256,uint256,uint256)": FunctionFragment;
    "updateURISlot(address,bytes,address,uint256,address,uint256,string)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "addBatchURISlotToNFTs"
      | "addBatchURISlotsToNFT"
      | "addURISlotToNFT"
      | "createCollections"
      | "createCollectionsWithoutURIs"
      | "externalCollectionURI"
      | "getIsFreeMinted"
      | "getProjectCollection"
      | "getProjectLastCollectionId"
      | "isSlotAddedForProject"
      | "mint"
      | "mintBatch"
      | "mintBatchWithURISlot"
      | "mintFree"
      | "mintFreeWithPreURI"
      | "mintWithPreURI"
      | "mintWithURISlots"
      | "registerExternalCollection"
      | "safeTransferFrom"
      | "supportsInterface"
      | "tokenProjectURI"
      | "transferTokenProjectURI"
      | "unlockFreeMintNFT"
      | "updateURISlot"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "addBatchURISlotToNFTs",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "addBatchURISlotsToNFT",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<string>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "addURISlotToNFT",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createCollections",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      ImQuark.CreateCollectionParamsStruct,
      PromiseOrValue<BytesLike>[][],
      PromiseOrValue<string>[][],
      PromiseOrValue<boolean>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createCollectionsWithoutURIs",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      ImQuark.CreateCollectionParamsStruct,
      PromiseOrValue<boolean>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "externalCollectionURI",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getIsFreeMinted",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getProjectCollection",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getProjectLastCollectionId",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isSlotAddedForProject",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "mint",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "mintBatch",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "mintBatchWithURISlot",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "mintFree",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "mintFreeWithPreURI",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "mintWithPreURI",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "mintWithURISlots",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<string>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "registerExternalCollection",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "safeTransferFrom",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenProjectURI",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferTokenProjectURI",
    values: [
      ImQuark.SellOrderStruct,
      ImQuark.BuyOrderStruct,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "unlockFreeMintNFT",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateURISlot",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "addBatchURISlotToNFTs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addBatchURISlotsToNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addURISlotToNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createCollections",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createCollectionsWithoutURIs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "externalCollectionURI",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getIsFreeMinted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProjectCollection",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProjectLastCollectionId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isSlotAddedForProject",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mintBatch", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "mintBatchWithURISlot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mintFree", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "mintFreeWithPreURI",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mintWithPreURI",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mintWithURISlots",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerExternalCollection",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenProjectURI",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferTokenProjectURI",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unlockFreeMintNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateURISlot",
    data: BytesLike
  ): Result;

  events: {
    "CollectionCreated(uint256,uint256,uint256,uint16,uint256,uint256,string[])": EventFragment;
    "NFTMinted(uint256,uint256,uint256,uint256,uint256,string,address)": EventFragment;
    "NFTMintedFree(uint256,uint256,uint256,int256,uint256,string,address)": EventFragment;
    "NFTMintedWithPreUri(uint256,uint256,uint256,string,uint256,address)": EventFragment;
    "ProjectSlotURIReset(uint256,uint256)": EventFragment;
    "ProjectURISlotAdded(uint256,uint256,string)": EventFragment;
    "ProjectURIUpdated(bytes,uint256,uint256,string)": EventFragment;
    "RoyaltySet(address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "CollectionCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NFTMinted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NFTMintedFree"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NFTMintedWithPreUri"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProjectSlotURIReset"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProjectURISlotAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProjectURIUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoyaltySet"): EventFragment;
}

export interface CollectionCreatedEventObject {
  projectId: BigNumber;
  templateId: BigNumber;
  collectionId: BigNumber;
  totalSupply: number;
  minId: BigNumber;
  maxId: BigNumber;
  collectionUris: string[];
}
export type CollectionCreatedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, number, BigNumber, BigNumber, string[]],
  CollectionCreatedEventObject
>;

export type CollectionCreatedEventFilter =
  TypedEventFilter<CollectionCreatedEvent>;

export interface NFTMintedEventObject {
  projectId: BigNumber;
  templateId: BigNumber;
  collectionId: BigNumber;
  variationId: BigNumber;
  tokenId: BigNumber;
  uri: string;
  to: string;
}
export type NFTMintedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, string, string],
  NFTMintedEventObject
>;

export type NFTMintedEventFilter = TypedEventFilter<NFTMintedEvent>;

export interface NFTMintedFreeEventObject {
  projectId: BigNumber;
  templateId: BigNumber;
  collectionId: BigNumber;
  variationId: BigNumber;
  tokenId: BigNumber;
  uri: string;
  to: string;
}
export type NFTMintedFreeEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, string, string],
  NFTMintedFreeEventObject
>;

export type NFTMintedFreeEventFilter = TypedEventFilter<NFTMintedFreeEvent>;

export interface NFTMintedWithPreUriEventObject {
  projectId: BigNumber;
  templateId: BigNumber;
  collectionId: BigNumber;
  uri: string;
  tokenId: BigNumber;
  to: string;
}
export type NFTMintedWithPreUriEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, string, BigNumber, string],
  NFTMintedWithPreUriEventObject
>;

export type NFTMintedWithPreUriEventFilter =
  TypedEventFilter<NFTMintedWithPreUriEvent>;

export interface ProjectSlotURIResetEventObject {
  tokenId: BigNumber;
  projectId: BigNumber;
}
export type ProjectSlotURIResetEvent = TypedEvent<
  [BigNumber, BigNumber],
  ProjectSlotURIResetEventObject
>;

export type ProjectSlotURIResetEventFilter =
  TypedEventFilter<ProjectSlotURIResetEvent>;

export interface ProjectURISlotAddedEventObject {
  tokenId: BigNumber;
  projectId: BigNumber;
  uri: string;
}
export type ProjectURISlotAddedEvent = TypedEvent<
  [BigNumber, BigNumber, string],
  ProjectURISlotAddedEventObject
>;

export type ProjectURISlotAddedEventFilter =
  TypedEventFilter<ProjectURISlotAddedEvent>;

export interface ProjectURIUpdatedEventObject {
  signature: string;
  projectId: BigNumber;
  tokenId: BigNumber;
  updatedUri: string;
}
export type ProjectURIUpdatedEvent = TypedEvent<
  [string, BigNumber, BigNumber, string],
  ProjectURIUpdatedEventObject
>;

export type ProjectURIUpdatedEventFilter =
  TypedEventFilter<ProjectURIUpdatedEvent>;

export interface RoyaltySetEventObject {
  reciever: string;
  royaltyAmount: BigNumber;
}
export type RoyaltySetEvent = TypedEvent<
  [string, BigNumber],
  RoyaltySetEventObject
>;

export type RoyaltySetEventFilter = TypedEventFilter<RoyaltySetEvent>;

export interface ImQuark extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ImQuarkInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addBatchURISlotToNFTs(
      owner: PromiseOrValue<string>,
      tokensContracts: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      projectId: PromiseOrValue<BigNumberish>,
      projectDefaultUris: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addBatchURISlotsToNFT(
      owner: PromiseOrValue<string>,
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectIds: PromiseOrValue<BigNumberish>[],
      projectSlotDefaultUris: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addURISlotToNFT(
      owner: PromiseOrValue<string>,
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      projectSlotDefaultUri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createCollections(
      royaltyReciever: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      signer: PromiseOrValue<string>,
      createParams: ImQuark.CreateCollectionParamsStruct,
      signatures: PromiseOrValue<BytesLike>[][],
      uris: PromiseOrValue<string>[][],
      isCollectionFree: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createCollectionsWithoutURIs(
      royaltyReciever: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      createParams: ImQuark.CreateCollectionParamsStruct,
      isCollectionFree: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    externalCollectionURI(
      collectionAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getIsFreeMinted(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isFreeMinted: boolean }>;

    getProjectCollection(
      templateId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string[],
        number,
        number
      ] & {
        _royaltyReceiver: string;
        _projectId: BigNumber;
        _templateId: BigNumber;
        _collectionId: BigNumber;
        minTokenId: BigNumber;
        maxTokenId: BigNumber;
        mintCount: BigNumber;
        collectionURIs: string[];
        totalSupply: number;
        mintType: number;
      }
    >;

    getProjectLastCollectionId(
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    isSlotAddedForProject(
      contractAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isAdded: boolean }>;

    mint(
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      variationId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mintBatch(
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateIds: PromiseOrValue<BigNumberish>[],
      collectionIds: PromiseOrValue<BigNumberish>[],
      variationIds: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mintBatchWithURISlot(
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateIds: PromiseOrValue<BigNumberish>[],
      collectionIds: PromiseOrValue<BigNumberish>[],
      variationIds: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      projectDefaultUri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mintFree(
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      variationId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mintFreeWithPreURI(
      signer: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      uri: PromiseOrValue<string>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mintWithPreURI(
      signer: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      uri: PromiseOrValue<string>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mintWithURISlots(
      to: PromiseOrValue<string>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      variationId: PromiseOrValue<BigNumberish>,
      projectIds: PromiseOrValue<BigNumberish>[],
      projectSlotDefaultUris: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    registerExternalCollection(
      tokenContract: PromiseOrValue<string>,
      templateUri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    tokenProjectURI(
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    transferTokenProjectURI(
      seller: ImQuark.SellOrderStruct,
      buyer: ImQuark.BuyOrderStruct,
      projectDefaultUri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unlockFreeMintNFT(
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateURISlot(
      owner: PromiseOrValue<string>,
      signature: PromiseOrValue<BytesLike>,
      project: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      updatedUri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  addBatchURISlotToNFTs(
    owner: PromiseOrValue<string>,
    tokensContracts: PromiseOrValue<string>[],
    tokenIds: PromiseOrValue<BigNumberish>[],
    projectId: PromiseOrValue<BigNumberish>,
    projectDefaultUris: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addBatchURISlotsToNFT(
    owner: PromiseOrValue<string>,
    tokenContract: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    projectIds: PromiseOrValue<BigNumberish>[],
    projectSlotDefaultUris: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addURISlotToNFT(
    owner: PromiseOrValue<string>,
    tokenContract: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    projectId: PromiseOrValue<BigNumberish>,
    projectSlotDefaultUri: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createCollections(
    royaltyReciever: PromiseOrValue<string>,
    projectId: PromiseOrValue<BigNumberish>,
    signer: PromiseOrValue<string>,
    createParams: ImQuark.CreateCollectionParamsStruct,
    signatures: PromiseOrValue<BytesLike>[][],
    uris: PromiseOrValue<string>[][],
    isCollectionFree: PromiseOrValue<boolean>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createCollectionsWithoutURIs(
    royaltyReciever: PromiseOrValue<string>,
    projectId: PromiseOrValue<BigNumberish>,
    createParams: ImQuark.CreateCollectionParamsStruct,
    isCollectionFree: PromiseOrValue<boolean>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  externalCollectionURI(
    collectionAddress: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  getIsFreeMinted(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getProjectCollection(
    templateId: PromiseOrValue<BigNumberish>,
    projectId: PromiseOrValue<BigNumberish>,
    collectionId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [
      string,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      string[],
      number,
      number
    ] & {
      _royaltyReceiver: string;
      _projectId: BigNumber;
      _templateId: BigNumber;
      _collectionId: BigNumber;
      minTokenId: BigNumber;
      maxTokenId: BigNumber;
      mintCount: BigNumber;
      collectionURIs: string[];
      totalSupply: number;
      mintType: number;
    }
  >;

  getProjectLastCollectionId(
    projectId: PromiseOrValue<BigNumberish>,
    templateId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  isSlotAddedForProject(
    contractAddress: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    projectId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  mint(
    to: PromiseOrValue<string>,
    projectId: PromiseOrValue<BigNumberish>,
    templateId: PromiseOrValue<BigNumberish>,
    collectionId: PromiseOrValue<BigNumberish>,
    variationId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  mintBatch(
    to: PromiseOrValue<string>,
    projectId: PromiseOrValue<BigNumberish>,
    templateIds: PromiseOrValue<BigNumberish>[],
    collectionIds: PromiseOrValue<BigNumberish>[],
    variationIds: PromiseOrValue<BigNumberish>[],
    amounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  mintBatchWithURISlot(
    to: PromiseOrValue<string>,
    projectId: PromiseOrValue<BigNumberish>,
    templateIds: PromiseOrValue<BigNumberish>[],
    collectionIds: PromiseOrValue<BigNumberish>[],
    variationIds: PromiseOrValue<BigNumberish>[],
    amounts: PromiseOrValue<BigNumberish>[],
    projectDefaultUri: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  mintFree(
    projectId: PromiseOrValue<BigNumberish>,
    templateId: PromiseOrValue<BigNumberish>,
    collectionId: PromiseOrValue<BigNumberish>,
    variationId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  mintFreeWithPreURI(
    signer: PromiseOrValue<string>,
    projectId: PromiseOrValue<BigNumberish>,
    templateId: PromiseOrValue<BigNumberish>,
    collectionId: PromiseOrValue<BigNumberish>,
    signature: PromiseOrValue<BytesLike>,
    uri: PromiseOrValue<string>,
    salt: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  mintWithPreURI(
    signer: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    projectId: PromiseOrValue<BigNumberish>,
    templateId: PromiseOrValue<BigNumberish>,
    collectionId: PromiseOrValue<BigNumberish>,
    signature: PromiseOrValue<BytesLike>,
    uri: PromiseOrValue<string>,
    salt: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  mintWithURISlots(
    to: PromiseOrValue<string>,
    templateId: PromiseOrValue<BigNumberish>,
    collectionId: PromiseOrValue<BigNumberish>,
    variationId: PromiseOrValue<BigNumberish>,
    projectIds: PromiseOrValue<BigNumberish>[],
    projectSlotDefaultUris: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  registerExternalCollection(
    tokenContract: PromiseOrValue<string>,
    templateUri: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  safeTransferFrom(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  supportsInterface(
    interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  tokenProjectURI(
    tokenContract: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    projectId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  transferTokenProjectURI(
    seller: ImQuark.SellOrderStruct,
    buyer: ImQuark.BuyOrderStruct,
    projectDefaultUri: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unlockFreeMintNFT(
    projectId: PromiseOrValue<BigNumberish>,
    templateId: PromiseOrValue<BigNumberish>,
    collectionId: PromiseOrValue<BigNumberish>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateURISlot(
    owner: PromiseOrValue<string>,
    signature: PromiseOrValue<BytesLike>,
    project: PromiseOrValue<string>,
    projectId: PromiseOrValue<BigNumberish>,
    tokenContract: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    updatedUri: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    addBatchURISlotToNFTs(
      owner: PromiseOrValue<string>,
      tokensContracts: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      projectId: PromiseOrValue<BigNumberish>,
      projectDefaultUris: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    addBatchURISlotsToNFT(
      owner: PromiseOrValue<string>,
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectIds: PromiseOrValue<BigNumberish>[],
      projectSlotDefaultUris: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    addURISlotToNFT(
      owner: PromiseOrValue<string>,
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      projectSlotDefaultUri: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    createCollections(
      royaltyReciever: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      signer: PromiseOrValue<string>,
      createParams: ImQuark.CreateCollectionParamsStruct,
      signatures: PromiseOrValue<BytesLike>[][],
      uris: PromiseOrValue<string>[][],
      isCollectionFree: PromiseOrValue<boolean>[],
      overrides?: CallOverrides
    ): Promise<void>;

    createCollectionsWithoutURIs(
      royaltyReciever: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      createParams: ImQuark.CreateCollectionParamsStruct,
      isCollectionFree: PromiseOrValue<boolean>[],
      overrides?: CallOverrides
    ): Promise<void>;

    externalCollectionURI(
      collectionAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    getIsFreeMinted(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getProjectCollection(
      templateId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string[],
        number,
        number
      ] & {
        _royaltyReceiver: string;
        _projectId: BigNumber;
        _templateId: BigNumber;
        _collectionId: BigNumber;
        minTokenId: BigNumber;
        maxTokenId: BigNumber;
        mintCount: BigNumber;
        collectionURIs: string[];
        totalSupply: number;
        mintType: number;
      }
    >;

    getProjectLastCollectionId(
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isSlotAddedForProject(
      contractAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    mint(
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      variationId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    mintBatch(
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateIds: PromiseOrValue<BigNumberish>[],
      collectionIds: PromiseOrValue<BigNumberish>[],
      variationIds: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    mintBatchWithURISlot(
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateIds: PromiseOrValue<BigNumberish>[],
      collectionIds: PromiseOrValue<BigNumberish>[],
      variationIds: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      projectDefaultUri: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    mintFree(
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      variationId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    mintFreeWithPreURI(
      signer: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      uri: PromiseOrValue<string>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    mintWithPreURI(
      signer: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      uri: PromiseOrValue<string>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    mintWithURISlots(
      to: PromiseOrValue<string>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      variationId: PromiseOrValue<BigNumberish>,
      projectIds: PromiseOrValue<BigNumberish>[],
      projectSlotDefaultUris: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    registerExternalCollection(
      tokenContract: PromiseOrValue<string>,
      templateUri: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    tokenProjectURI(
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    transferTokenProjectURI(
      seller: ImQuark.SellOrderStruct,
      buyer: ImQuark.BuyOrderStruct,
      projectDefaultUri: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    unlockFreeMintNFT(
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateURISlot(
      owner: PromiseOrValue<string>,
      signature: PromiseOrValue<BytesLike>,
      project: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      updatedUri: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "CollectionCreated(uint256,uint256,uint256,uint16,uint256,uint256,string[])"(
      projectId?: null,
      templateId?: null,
      collectionId?: null,
      totalSupply?: null,
      minId?: null,
      maxId?: null,
      collectionUris?: null
    ): CollectionCreatedEventFilter;
    CollectionCreated(
      projectId?: null,
      templateId?: null,
      collectionId?: null,
      totalSupply?: null,
      minId?: null,
      maxId?: null,
      collectionUris?: null
    ): CollectionCreatedEventFilter;

    "NFTMinted(uint256,uint256,uint256,uint256,uint256,string,address)"(
      projectId?: null,
      templateId?: null,
      collectionId?: null,
      variationId?: null,
      tokenId?: null,
      uri?: null,
      to?: null
    ): NFTMintedEventFilter;
    NFTMinted(
      projectId?: null,
      templateId?: null,
      collectionId?: null,
      variationId?: null,
      tokenId?: null,
      uri?: null,
      to?: null
    ): NFTMintedEventFilter;

    "NFTMintedFree(uint256,uint256,uint256,int256,uint256,string,address)"(
      projectId?: null,
      templateId?: null,
      collectionId?: null,
      variationId?: null,
      tokenId?: null,
      uri?: null,
      to?: null
    ): NFTMintedFreeEventFilter;
    NFTMintedFree(
      projectId?: null,
      templateId?: null,
      collectionId?: null,
      variationId?: null,
      tokenId?: null,
      uri?: null,
      to?: null
    ): NFTMintedFreeEventFilter;

    "NFTMintedWithPreUri(uint256,uint256,uint256,string,uint256,address)"(
      projectId?: null,
      templateId?: null,
      collectionId?: null,
      uri?: null,
      tokenId?: null,
      to?: null
    ): NFTMintedWithPreUriEventFilter;
    NFTMintedWithPreUri(
      projectId?: null,
      templateId?: null,
      collectionId?: null,
      uri?: null,
      tokenId?: null,
      to?: null
    ): NFTMintedWithPreUriEventFilter;

    "ProjectSlotURIReset(uint256,uint256)"(
      tokenId?: null,
      projectId?: null
    ): ProjectSlotURIResetEventFilter;
    ProjectSlotURIReset(
      tokenId?: null,
      projectId?: null
    ): ProjectSlotURIResetEventFilter;

    "ProjectURISlotAdded(uint256,uint256,string)"(
      tokenId?: null,
      projectId?: null,
      uri?: null
    ): ProjectURISlotAddedEventFilter;
    ProjectURISlotAdded(
      tokenId?: null,
      projectId?: null,
      uri?: null
    ): ProjectURISlotAddedEventFilter;

    "ProjectURIUpdated(bytes,uint256,uint256,string)"(
      signature?: null,
      projectId?: null,
      tokenId?: null,
      updatedUri?: null
    ): ProjectURIUpdatedEventFilter;
    ProjectURIUpdated(
      signature?: null,
      projectId?: null,
      tokenId?: null,
      updatedUri?: null
    ): ProjectURIUpdatedEventFilter;

    "RoyaltySet(address,uint256)"(
      reciever?: null,
      royaltyAmount?: null
    ): RoyaltySetEventFilter;
    RoyaltySet(reciever?: null, royaltyAmount?: null): RoyaltySetEventFilter;
  };

  estimateGas: {
    addBatchURISlotToNFTs(
      owner: PromiseOrValue<string>,
      tokensContracts: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      projectId: PromiseOrValue<BigNumberish>,
      projectDefaultUris: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addBatchURISlotsToNFT(
      owner: PromiseOrValue<string>,
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectIds: PromiseOrValue<BigNumberish>[],
      projectSlotDefaultUris: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addURISlotToNFT(
      owner: PromiseOrValue<string>,
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      projectSlotDefaultUri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createCollections(
      royaltyReciever: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      signer: PromiseOrValue<string>,
      createParams: ImQuark.CreateCollectionParamsStruct,
      signatures: PromiseOrValue<BytesLike>[][],
      uris: PromiseOrValue<string>[][],
      isCollectionFree: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createCollectionsWithoutURIs(
      royaltyReciever: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      createParams: ImQuark.CreateCollectionParamsStruct,
      isCollectionFree: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    externalCollectionURI(
      collectionAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getIsFreeMinted(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getProjectCollection(
      templateId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getProjectLastCollectionId(
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isSlotAddedForProject(
      contractAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    mint(
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      variationId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    mintBatch(
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateIds: PromiseOrValue<BigNumberish>[],
      collectionIds: PromiseOrValue<BigNumberish>[],
      variationIds: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    mintBatchWithURISlot(
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateIds: PromiseOrValue<BigNumberish>[],
      collectionIds: PromiseOrValue<BigNumberish>[],
      variationIds: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      projectDefaultUri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    mintFree(
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      variationId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    mintFreeWithPreURI(
      signer: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      uri: PromiseOrValue<string>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    mintWithPreURI(
      signer: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      uri: PromiseOrValue<string>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    mintWithURISlots(
      to: PromiseOrValue<string>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      variationId: PromiseOrValue<BigNumberish>,
      projectIds: PromiseOrValue<BigNumberish>[],
      projectSlotDefaultUris: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    registerExternalCollection(
      tokenContract: PromiseOrValue<string>,
      templateUri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenProjectURI(
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferTokenProjectURI(
      seller: ImQuark.SellOrderStruct,
      buyer: ImQuark.BuyOrderStruct,
      projectDefaultUri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unlockFreeMintNFT(
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateURISlot(
      owner: PromiseOrValue<string>,
      signature: PromiseOrValue<BytesLike>,
      project: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      updatedUri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addBatchURISlotToNFTs(
      owner: PromiseOrValue<string>,
      tokensContracts: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      projectId: PromiseOrValue<BigNumberish>,
      projectDefaultUris: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addBatchURISlotsToNFT(
      owner: PromiseOrValue<string>,
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectIds: PromiseOrValue<BigNumberish>[],
      projectSlotDefaultUris: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addURISlotToNFT(
      owner: PromiseOrValue<string>,
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      projectSlotDefaultUri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createCollections(
      royaltyReciever: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      signer: PromiseOrValue<string>,
      createParams: ImQuark.CreateCollectionParamsStruct,
      signatures: PromiseOrValue<BytesLike>[][],
      uris: PromiseOrValue<string>[][],
      isCollectionFree: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createCollectionsWithoutURIs(
      royaltyReciever: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      createParams: ImQuark.CreateCollectionParamsStruct,
      isCollectionFree: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    externalCollectionURI(
      collectionAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getIsFreeMinted(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getProjectCollection(
      templateId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getProjectLastCollectionId(
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isSlotAddedForProject(
      contractAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    mint(
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      variationId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    mintBatch(
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateIds: PromiseOrValue<BigNumberish>[],
      collectionIds: PromiseOrValue<BigNumberish>[],
      variationIds: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    mintBatchWithURISlot(
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateIds: PromiseOrValue<BigNumberish>[],
      collectionIds: PromiseOrValue<BigNumberish>[],
      variationIds: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      projectDefaultUri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    mintFree(
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      variationId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    mintFreeWithPreURI(
      signer: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      uri: PromiseOrValue<string>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    mintWithPreURI(
      signer: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      uri: PromiseOrValue<string>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    mintWithURISlots(
      to: PromiseOrValue<string>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      variationId: PromiseOrValue<BigNumberish>,
      projectIds: PromiseOrValue<BigNumberish>[],
      projectSlotDefaultUris: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    registerExternalCollection(
      tokenContract: PromiseOrValue<string>,
      templateUri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenProjectURI(
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      projectId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferTokenProjectURI(
      seller: ImQuark.SellOrderStruct,
      buyer: ImQuark.BuyOrderStruct,
      projectDefaultUri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unlockFreeMintNFT(
      projectId: PromiseOrValue<BigNumberish>,
      templateId: PromiseOrValue<BigNumberish>,
      collectionId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateURISlot(
      owner: PromiseOrValue<string>,
      signature: PromiseOrValue<BytesLike>,
      project: PromiseOrValue<string>,
      projectId: PromiseOrValue<BigNumberish>,
      tokenContract: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      updatedUri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
